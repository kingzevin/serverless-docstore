// Generated by CoffeeScript 1.12.7
(function() {
  var MongoManager, ObjectId, db, logger, metrics, ref;

  ref = require("./mongojs"), db = ref.db, ObjectId = ref.ObjectId;

  logger = require('logger-sharelatex');

  metrics = require('metrics-sharelatex');

  module.exports = MongoManager = {
    findDoc: function(project_id, doc_id, filter, callback) {
      if (callback == null) {
        callback = function(error, doc) {};
      }
      return db.docs.find({
        _id: ObjectId(doc_id.toString()),
        project_id: ObjectId(project_id.toString())
      }, filter, function(error, docs) {
        if (docs == null) {
          docs = [];
        }
        return callback(error, docs[0]);
      });
    },
    getProjectsDocs: function(project_id, options, filter, callback) {
      var query;
      if (options == null) {
        options = {
          include_deleted: true
        };
      }
      query = {
        project_id: ObjectId(project_id.toString())
      };
      if (!options.include_deleted) {
        query.deleted = {
          $ne: true
        };
      }
      return db.docs.find(query, filter, callback);
    },
    getArchivedProjectDocs: function(project_id, callback) {
      var query;
      query = {
        project_id: ObjectId(project_id.toString()),
        inS3: true
      };
      return db.docs.find(query, {}, callback);
    },
    upsertIntoDocCollection: function(project_id, doc_id, updates, callback) {
      var update;
      update = {
        $set: updates,
        $inc: {
          rev: 1
        },
        $unset: {
          inS3: true
        }
      };
      update.$set["project_id"] = ObjectId(project_id);
      return db.docs.update({
        _id: ObjectId(doc_id)
      }, update, {
        upsert: true
      }, callback);
    },
    markDocAsDeleted: function(project_id, doc_id, callback) {
      return db.docs.update({
        _id: ObjectId(doc_id),
        project_id: ObjectId(project_id)
      }, {
        $set: {
          deleted: true
        }
      }, callback);
    },
    markDocAsArchived: function(doc_id, rev, callback) {
      var query, update;
      update = {
        $set: {},
        $unset: {}
      };
      update.$set["inS3"] = true;
      update.$unset["lines"] = true;
      update.$unset["ranges"] = true;
      query = {
        _id: doc_id,
        rev: rev
      };
      return db.docs.update(query, update, function(err) {
        return callback(err);
      });
    },
    getDocVersion: function(doc_id, callback) {
      if (callback == null) {
        callback = function(error, version) {};
      }
      return db.docOps.find({
        doc_id: ObjectId(doc_id)
      }, {
        version: 1
      }, function(error, docs) {
        if (error != null) {
          return callback(error);
        }
        if (docs.length < 1 || (docs[0].version == null)) {
          return callback(null, 0);
        } else {
          return callback(null, docs[0].version);
        }
      });
    },
    setDocVersion: function(doc_id, version, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return db.docOps.update({
        doc_id: ObjectId(doc_id)
      }, {
        $set: {
          version: version
        }
      }, {
        upsert: true
      }, callback);
    },
    destroyDoc: function(doc_id, callback) {
      return db.docs.remove({
        _id: ObjectId(doc_id)
      }, function(err) {
        if (err != null) {
          return callback(err);
        }
        return db.docOps.remove({
          doc_id: ObjectId(doc_id)
        }, callback);
      });
    }
  };

  ['findDoc', 'getProjectsDocs', 'getArchivedProjectDocs', 'upsertIntoDocCollection', 'markDocAsArchived', 'getDocVersion', 'setDocVersion'].map(function(method) {
    return metrics.timeAsyncMethod(MongoManager, method, 'mongo.MongoManager', logger);
  });

}).call(this);

//# sourceMappingURL=MongoManager.js.map
